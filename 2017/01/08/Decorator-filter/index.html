<!doctype html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  
    
      
    

    
  

  
    
      
    

    
  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Monda:300,300italic,400,400italic,700,700italic|Lobster Two:300,300italic,400,400italic,700,700italic|PT Mono:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.0" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="j2ee,filter,servlet," />








  <link rel="shortcut icon" type="image/x-icon" href="/images/favicon00.ico?v=5.1.0" />






<meta name="description" content="在filter中可以得到代表用户请求和响应的request、response对象，因此在编程中可以使用Decorator(装饰器)模式对request、response对象进行包装，再把包装对象传给目标资源，从而实现一些特殊需求。">
<meta property="og:type" content="article">
<meta property="og:title" content="servlet过滤器filter使用装饰器模式增强response和request对象">
<meta property="og:url" content="http://www.yanglc.com/2017/01/08/Decorator-filter/index.html">
<meta property="og:site_name" content="Sully">
<meta property="og:description" content="在filter中可以得到代表用户请求和响应的request、response对象，因此在编程中可以使用Decorator(装饰器)模式对request、response对象进行包装，再把包装对象传给目标资源，从而实现一些特殊需求。">
<meta property="og:image" content="http://upload-images.jianshu.io/upload_images/3385496-6d4841e8ac76ce11.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:updated_time" content="2017-01-08T14:45:43.355Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="servlet过滤器filter使用装饰器模式增强response和request对象">
<meta name="twitter:description" content="在filter中可以得到代表用户请求和响应的request、response对象，因此在编程中可以使用Decorator(装饰器)模式对request、response对象进行包装，再把包装对象传给目标资源，从而实现一些特殊需求。">
<meta name="twitter:image" content="http://upload-images.jianshu.io/upload_images/3385496-6d4841e8ac76ce11.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '6370579524316300000',
      author: '奥雷里亚诺将军'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://www.yanglc.com/2017/01/08/Decorator-filter/"/>





  <title> servlet过滤器filter使用装饰器模式增强response和request对象 | Sully </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  










  
  
    
  

  <div class="container one-collumn sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">Sully</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
    
      <p class="site-subtitle">凡人皆有一死，凡人皆需侍奉</p>
    
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-commonweal">
          <a href="/404.html" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-heartbeat"></i> <br />
            
            公益404
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://www.yanglc.com/2017/01/08/Decorator-filter/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="杨重山">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/image/touxiang.jpg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="Sully">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="Sully" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                servlet过滤器filter使用装饰器模式增强response和request对象
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-01-08T22:41:07+08:00">
                2017-01-08
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/j2ee/" itemprop="url" rel="index">
                    <span itemprop="name">j2ee</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/01/08/Decorator-filter/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2017/01/08/Decorator-filter/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        <hr>
<p><img src="http://upload-images.jianshu.io/upload_images/3385496-6d4841e8ac76ce11.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>在filter中可以得到代表用户请求和响应的request、response对象，因此在编程中可以使用Decorator(装饰器)模式对request、response对象进行包装，再把包装对象传给目标资源，从而实现一些特殊需求。</p>
<hr>
<a id="more"></a>
<h2 id="一、Decorator设计模式"><a href="#一、Decorator设计模式" class="headerlink" title="一、Decorator设计模式"></a>一、Decorator设计模式</h2><h3 id="1-1、Decorator设计模式介绍"><a href="#1-1、Decorator设计模式介绍" class="headerlink" title="1.1、Decorator设计模式介绍"></a>1.1、Decorator设计模式介绍</h3><p>　　当某个对象的方法不适应业务需求时，通常有2种方式可以对方法进行增强：<br>编写子类，覆盖需增强的方法。<br>使用Decorator设计模式对方法进行增强。</p>
<p>　　装饰模式又名包装(Wrapper)模式。装饰模式以对客户端透明的方式扩展对象的功能，是继承关系的一个替代方案。<strong>装饰模式是在不必改变原类文件和使用继承的情况下，动态的扩展一个对象的功能。它是通过创建一个包装对象，也就是装饰来包裹真实的对象。<br>那么在实际应用中遇到需增强对象的方法时，到底选用哪种方式比较好呢？这个没有具体的定式，只能是根据具体的需求来采用具体的方式，不过有一种情况下，必须使用Decorator设计模式：即被增强的对象，开发人员只能得到它的对象，无法得到它的class文件</strong>。</p>
<p>比如request、response对象，开发人员之所以在servlet中能通过sun公司定义的HttpServletRequest\response接口去操作这些对象，是因为Tomcat服务器厂商编写了request、response接口的实现类。web服务器在调用servlet时，会用这些接口的实现类创建出对象，然后传递给servlet程序。此种情况下，由于开发人员根本不知道服务器厂商编写的request、response接口的实现类是哪个？在程序中只能拿到服务器厂商提供的对象，因此就只能采用Decorator设计模式对这些对象进行增强。</p>
<h3 id="1-2、Decorator设计模式的实现"><a href="#1-2、Decorator设计模式的实现" class="headerlink" title="1.2、Decorator设计模式的实现"></a>1.2、Decorator设计模式的实现</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">1.首先看需要被增强对象继承了什么接口或父类，编写一个类也去继承这些接口或父类。　　</div><div class="line"></div><div class="line">2.在类中定义一个变量，变量类型即需增强对象的类型。　　</div><div class="line"></div><div class="line">3.在类中定义一个构造函数，接收需增强的对象。　　</div><div class="line"></div><div class="line">4.覆盖需增强的方法，编写增强的代码。</div></pre></td></tr></table></figure>
<h2 id="二、使用Decorator设计模式增强request对象"><a href="#二、使用Decorator设计模式增强request对象" class="headerlink" title="二、使用Decorator设计模式增强request对象"></a>二、使用Decorator设计模式增强request对象</h2><p>　　Servlet API 中提供了一个request对象的Decorator设计模式的默认实现类HttpServletRequestWrapper，HttpServletRequestWrapper 类实现了request 接口中的所有方法，但这些方法的内部实现都是仅仅调用了一下所包装的的 request 对象的对应方法，以避免用户在对request对象进行增强时需要实现request接口中的所有方法。</p>
<h3 id="2-1、使用Decorator模式包装request对象解决get和post请求方式下的中文乱码问题"><a href="#2-1、使用Decorator模式包装request对象解决get和post请求方式下的中文乱码问题" class="headerlink" title="2.1、使用Decorator模式包装request对象解决get和post请求方式下的中文乱码问题"></a>2.1、使用Decorator模式包装request对象解决get和post请求方式下的中文乱码问题</h3><p>　　编写一个用于处理中文乱码的过滤器CharacterEncodingFilter，代码如下：<br>    package me.gacl.web.filter;</p>
<pre><code>import java.io.IOException;

import javax.servlet.Filter;
import javax.servlet.FilterChain;
import javax.servlet.FilterConfig;
import javax.servlet.ServletException;
import javax.servlet.ServletRequest;
import javax.servlet.ServletResponse;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletRequestWrapper;
import javax.servlet.http.HttpServletResponse;

/**
* @ClassName: CharacterEncodingFilter
* @Description: 此过滤器用来解决解决get、post请求方式下的中文乱码问题
* @author: 孤傲苍狼
* @date: 2014-8-31 下午11:09:37
*
*/ 
public class CharacterEncodingFilter implements Filter {

    private FilterConfig filterConfig = null;
    //设置默认的字符编码
    private String defaultCharset = &quot;UTF-8&quot;;

    public void doFilter(ServletRequest req, ServletResponse resp,
            FilterChain chain) throws IOException, ServletException {

        HttpServletRequest request = (HttpServletRequest) req;
        HttpServletResponse response = (HttpServletResponse) resp;
        //得到在web.xml中配置的字符编码
        String charset = filterConfig.getInitParameter(&quot;charset&quot;);
        if(charset==null){
            charset = defaultCharset;
        }
        request.setCharacterEncoding(charset);
        response.setCharacterEncoding(charset);
        response.setContentType(&quot;text/html;charset=&quot;+charset);

        MyCharacterEncodingRequest requestWrapper = new MyCharacterEncodingRequest(request);
        chain.doFilter(requestWrapper, response);
    }

    public void init(FilterConfig filterConfig) throws ServletException {
        //得到过滤器的初始化配置信息
        this.filterConfig = filterConfig;
    }

    public void destroy() {

    }
}

/**
* @ClassName: MyCharacterEncodingRequest
* @Description: Servlet API中提供了一个request对象的Decorator设计模式的默认实现类HttpServletRequestWrapper,
* (HttpServletRequestWrapper类实现了request接口中的所有方法，但这些方法的内部实现都是仅仅调用了一下所包装的的 request对象的对应方法)
* 以避免用户在对request对象进行增强时需要实现request接口中的所有方法。
* 所以当需要增强request对象时，只需要写一个类继承HttpServletRequestWrapper类，然后在重写需要增强的方法即可
* @author: 孤傲苍狼
* @date: 2014-9-2 下午10:42:57
*     1.实现与被增强对象相同的接口 
    2、定义一个变量记住被增强对象
    3、定义一个构造函数，接收被增强对象
    4、覆盖需要增强的方法
    5、对于不想增强的方法，直接调用被增强对象（目标对象）的方法
*/ 
class MyCharacterEncodingRequest extends HttpServletRequestWrapper{
    //定义一个变量记住被增强对象(request对象是需要被增强的对象)
    private HttpServletRequest request;
    //定义一个构造函数，接收被增强对象
    public MyCharacterEncodingRequest(HttpServletRequest request) {
        super(request);
        this.request = request;
    }
    /* 覆盖需要增强的getParameter方法
     * @see javax.servlet.ServletRequestWrapper#getParameter(java.lang.String)
     */
    @Override
    public String getParameter(String name) {
        try{
            //获取参数的值
            String value= this.request.getParameter(name);
            if(value==null){
                return null;
            }
            //如果不是以get方式提交数据的，就直接返回获取到的值
            if(!this.request.getMethod().equalsIgnoreCase(&quot;get&quot;)) {
                return value;
            }else{
                //如果是以get方式提交数据的，就对获取到的值进行转码处理
                value = new String(value.getBytes(&quot;ISO8859-1&quot;),this.request.getCharacterEncoding());
                return value;
            }
        }catch (Exception e) {
            throw new RuntimeException(e);
        }
    }
}
</code></pre><p>在web.xml文件中配置CharacterEncodingFilter</p>
<pre><code>&lt;!--配置字符过滤器，解决get、post请求方式下的中文乱码问题--&gt;
  &lt;filter&gt;
      &lt;filter-name&gt;CharacterEncodingFilter&lt;/filter-name&gt;
      &lt;filter-class&gt;me.gacl.web.filter.CharacterEncodingFilter&lt;/filter-class&gt;
  &lt;/filter&gt;

  &lt;filter-mapping&gt;
      &lt;filter-name&gt;CharacterEncodingFilter&lt;/filter-name&gt;
      &lt;url-pattern&gt;/*&lt;/url-pattern&gt;
  &lt;/filter-mapping&gt;
</code></pre><p>编写jsp测试页面，如下：</p>
<pre><code>&lt;%@ page language=&quot;java&quot; pageEncoding=&quot;UTF-8&quot;%&gt;
&lt;%--引入jstl标签库 --%&gt;
&lt;%@taglib uri=&quot;http://java.sun.com/jsp/jstl/core&quot; prefix=&quot;c&quot;%&gt;
&lt;!DOCTYPE HTML&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;title&gt;使用字符过滤器解决解决get、post请求方式下的中文乱码问题&lt;/title&gt;
  &lt;/head&gt;

  &lt;body&gt;
       &lt;%--使用c:url标签构建url，构建好的url存储在servletDemo1变量中--%&gt;
       &lt;c:url value=&quot;/servlet/ServletDemo1&quot; scope=&quot;page&quot; var=&quot;servletDemo1&quot;&gt;
           &lt;%--构建的url的附带的中文参数 ，参数名是：username，值是：孤傲苍狼--%&gt;
           &lt;c:param name=&quot;username&quot; value=&quot;孤傲苍狼&quot;&gt;&lt;/c:param&gt;
       &lt;/c:url&gt;
      &lt;%--使用get的方式访问 --%&gt;
       &lt;a href=&quot;${servletDemo1}&quot;&gt;超链接(get方式请求)&lt;/a&gt;
       &lt;hr/&gt;
       &lt;%--使用post方式提交表单 --%&gt;
       &lt;form action=&quot;${pageContext.request.contextPath}/servlet/ServletDemo1&quot; method=&quot;post&quot;&gt;
           用户名：&lt;input type=&quot;text&quot; name=&quot;username&quot; value=&quot;孤傲苍狼&quot; /&gt;
           &lt;input type=&quot;submit&quot; value=&quot;post方式提交&quot;&gt;
       &lt;/form&gt;

  &lt;/body&gt;
&lt;/html&gt;
</code></pre><p>编写处理用户请求的ServletDemo1</p>
<pre><code>package me.gacl.web.controller;

import java.io.IOException;
import java.io.PrintWriter;

import javax.servlet.ServletException;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

public class ServletDemo1 extends HttpServlet {

    public void doGet(HttpServletRequest request, HttpServletResponse response)
            throws ServletException, IOException {
        //接收参数
        String username = request.getParameter(&quot;username&quot;);
        //获取请求方式
        String method = request.getMethod();
        //获取输出流
        PrintWriter out = response.getWriter();
        out.write(&quot;请求的方式：&quot;+method);
        out.write(&quot;&lt;br/&gt;&quot;);
        out.write(&quot;接收到的参数：&quot;+username);
    }

    public void doPost(HttpServletRequest request, HttpServletResponse response)
            throws ServletException, IOException {
        doGet(request, response);
    }

}
</code></pre><h3 id="2-2、使用Decorator模式包装request对象实现html标签转义功能"><a href="#2-2、使用Decorator模式包装request对象实现html标签转义功能" class="headerlink" title="2.2、使用Decorator模式包装request对象实现html标签转义功能"></a>2.2、使用Decorator模式包装request对象实现html标签转义功能</h3><p>　　编写一个html转义过滤器，代码如下：
　　</p>
<pre><code>package me.gacl.web.filter;
import java.io.IOException;

import javax.servlet.Filter;
import javax.servlet.FilterChain;
import javax.servlet.FilterConfig;
import javax.servlet.ServletException;
import javax.servlet.ServletRequest;
import javax.servlet.ServletResponse;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletRequestWrapper;
import javax.servlet.http.HttpServletResponse;

/**
* @ClassName: HtmlFilter
* @Description: html转义过滤器
* @author: 孤傲苍狼
* @date: 2014-9-2 下午11:28:41
*
*/ 
public class HtmlFilter implements Filter {

    public void doFilter(ServletRequest req, ServletResponse resp,
            FilterChain chain) throws IOException, ServletException {

        HttpServletRequest request = (HttpServletRequest) req;
        HttpServletResponse response = (HttpServletResponse) resp;

        MyHtmlRequest myrequest = new MyHtmlRequest(request);
        chain.doFilter(myrequest, response);

    }


    public void destroy() {

    }


    public void init(FilterConfig filterConfig) throws ServletException {

    }
}

/**
* @ClassName: MyHtmlRequest
* @Description: 使用Decorator模式包装request对象，实现html标签转义功能
* @author: 孤傲苍狼
* @date: 2014-9-2 下午11:29:09
*
*/ 
class MyHtmlRequest extends HttpServletRequestWrapper {

    private HttpServletRequest request;

    public MyHtmlRequest(HttpServletRequest request) {
        super(request);
        this.request = request;
    }

    /* 覆盖需要增强的getParameter方法
     * @see javax.servlet.ServletRequestWrapper#getParameter(java.lang.String)
     */
    @Override
    public String getParameter(String name) {
        String value = this.request.getParameter(name);
        if (value == null) {
            return null;
        }
        //调用filter转义value中的html标签
        return filter(value);
    }

    /**
    * @Method: filter
    * @Description: 过滤内容中的html标签
    * @Anthor:孤傲苍狼
    * @param message
    * @return
    */ 
    public String filter(String message) {
        if (message == null){
            return null;
        }
        char content[] = new char[message.length()];
        message.getChars(0, message.length(), content, 0);
        StringBuffer result = new StringBuffer(content.length + 50);
        for (int i = 0; i &lt; content.length; i++) {
            switch (content[i]) {
            case &apos;&lt;&apos;:
                result.append(&quot;&amp;lt;&quot;);
                break;
            case &apos;&gt;&apos;:
                result.append(&quot;&amp;gt;&quot;);
                break;
            case &apos;&amp;&apos;:
                result.append(&quot;&amp;amp;&quot;);
                break;
            case &apos;&quot;&apos;:
                result.append(&quot;&amp;quot;&quot;);
                break;
            default:
                result.append(content[i]);
            }
        }
        return result.toString();
    }
}
</code></pre><p>在web.xml文件中配置HtmlFilter</p>
<pre><code>&lt;!--配置Html过滤器，转义内容中的html标签--&gt;
  &lt;filter&gt;
      &lt;filter-name&gt;HtmlFilter&lt;/filter-name&gt;
      &lt;filter-class&gt;me.gacl.web.filter.HtmlFilter&lt;/filter-class&gt;
  &lt;/filter&gt;

  &lt;filter-mapping&gt;
      &lt;filter-name&gt;HtmlFilter&lt;/filter-name&gt;
      &lt;url-pattern&gt;/*&lt;/url-pattern&gt;
  &lt;/filter-mapping&gt;
</code></pre><p>编写jsp测试页面，如下</p>
<pre><code>&lt;%@ page language=&quot;java&quot; import=&quot;java.util.*&quot; pageEncoding=&quot;UTF-8&quot;%&gt;
&lt;!DOCTYPE HTML&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;title&gt;html过滤器测试&lt;/title&gt;
  &lt;/head&gt;

  &lt;body&gt;
       &lt;form action=&quot;${pageContext.request.contextPath}/servlet/ServletDemo2&quot; method=&quot;post&quot;&gt;
           留言:
           &lt;textarea rows=&quot;8&quot; cols=&quot;70&quot; name=&quot;message&quot;&gt;
           &lt;script type=&quot;text/javascript&quot;&gt;
           while(true){
               alert(&quot;死循环了，我会不停地弹出了&quot;);
           }
           &lt;/script&gt;
        &lt;a href=&quot;http://www.cnblogs.com&quot;&gt;访问博客园&lt;/a&gt;
           &lt;/textarea&gt;
           &lt;input type=&quot;submit&quot; value=&quot;发表&quot;&gt;
       &lt;/form&gt;
  &lt;/body&gt;
&lt;/html&gt;
</code></pre><p>编写处理用户请求的ServletDemo2</p>
<pre><code>package me.gacl.web.controller;

import java.io.IOException;

import javax.servlet.ServletException;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

public class ServletDemo2 extends HttpServlet {

    public void doGet(HttpServletRequest request, HttpServletResponse response)
            throws ServletException, IOException {
        //获取用户输入的内容
        String message = request.getParameter(&quot;message&quot;);
        response.getWriter().write(&quot;您上次的留言是：&lt;br/&gt;&quot; + message);
    }

    public void doPost(HttpServletRequest request, HttpServletResponse response)
            throws ServletException, IOException {
        doGet(request, response);
    }
}
</code></pre><h3 id="2-3、使用Decorator模式包装request对象实现敏感字符过滤功能"><a href="#2-3、使用Decorator模式包装request对象实现敏感字符过滤功能" class="headerlink" title="2.3、使用Decorator模式包装request对象实现敏感字符过滤功能"></a>2.3、使用Decorator模式包装request对象实现敏感字符过滤功能</h3><p>　　编写一个敏感字符过滤器，代码如下
　　</p>
<pre><code>package me.gacl.web.filter;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.UnsupportedEncodingException;
import java.util.ArrayList;
import java.util.List;
import javax.servlet.Filter;
import javax.servlet.FilterChain;
import javax.servlet.FilterConfig;
import javax.servlet.ServletException;
import javax.servlet.ServletRequest;
import javax.servlet.ServletResponse;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletRequestWrapper;
import javax.servlet.http.HttpServletResponse;

/**
* @ClassName: DirtyFilter
* @Description: 敏感词过滤器
* @author: 孤傲苍狼
* @date: 2014-9-6 上午10:43:11
*
*/ 
public class DirtyFilter implements Filter {

    private FilterConfig config = null;

    @Override
    public void init(FilterConfig filterConfig) throws ServletException {
        this.config = filterConfig;
    }

    @Override
    public void doFilter(ServletRequest req, ServletResponse resp,
            FilterChain chain) throws IOException, ServletException {

        HttpServletRequest request = (HttpServletRequest) req;
        HttpServletResponse response = (HttpServletResponse) resp;
        DirtyRequest dirtyrequest = new DirtyRequest(request);

        chain.doFilter(dirtyrequest, response);
    }

    @Override
    public void destroy() {

    }

    /**
    * @Method: getDirtyWords
    * @Description: 获取敏感字符
    * @Anthor:孤傲苍狼
    *
    * @return
    */ 
    private List&lt;String&gt; getDirtyWords(){
        List&lt;String&gt; dirtyWords = new ArrayList&lt;String&gt;();
        String dirtyWordPath = config.getInitParameter(&quot;dirtyWord&quot;);
        InputStream inputStream = config.getServletContext().getResourceAsStream(dirtyWordPath);
        InputStreamReader is = null;
        try {
            is = new InputStreamReader(inputStream,&quot;UTF-8&quot;);
        } catch (UnsupportedEncodingException e2) {
            e2.printStackTrace();
        }
        BufferedReader reader = new BufferedReader(is);
        String line;
        try {
            while ((line = reader.readLine())!= null) {//如果 line为空说明读完了
                dirtyWords.add(line);
            }
        } catch (IOException e) {
            e.printStackTrace();
        } 
        return dirtyWords;
    }

    /**
    * @ClassName: DirtyRequest
    * @Description: 使用Decorator模式包装request对象，实现敏感字符过滤功能
    * @author: 孤傲苍狼
    * @date: 2014-9-6 上午11:56:35
    *
    */ 
    class DirtyRequest extends HttpServletRequestWrapper{

        private List&lt;String&gt; dirtyWords = getDirtyWords();
        private HttpServletRequest request;
        public DirtyRequest(HttpServletRequest request) {
            super(request);
            this.request = request;
        }
        /* 重写getParameter方法，实现对敏感字符的过滤
         * @see javax.servlet.ServletRequestWrapper#getParameter(java.lang.String)
         */
        @Override
        public String getParameter(String name) {

            String value = this.request.getParameter(name);
            if(value==null){
                return null;
            }

            for(String dirtyWord : dirtyWords){
                if(value.contains(dirtyWord)){
                    System.out.println(&quot;内容中包含敏感词：&quot;+dirtyWord+&quot;，将会被替换成****&quot;);
                    //替换敏感字符
                    value = value.replace(dirtyWord, &quot;****&quot;);
                }
            }
            return value;
        }
    }
}
</code></pre><p>在web.xml文件中配置DirtyFilter</p>
<pre><code>&lt;!--配置敏感字符过滤器--&gt;
  &lt;filter&gt;
      &lt;filter-name&gt;DirtyFilter&lt;/filter-name&gt;
      &lt;filter-class&gt;me.gacl.web.filter.DirtyFilter&lt;/filter-class&gt;
      &lt;!-- 配置要过滤的敏感字符文件 --&gt;
      &lt;init-param&gt;
         &lt;param-name&gt;dirtyWord&lt;/param-name&gt;    
         &lt;param-value&gt;/WEB-INF/DirtyWord.txt&lt;/param-value&gt;
    &lt;/init-param&gt;
  &lt;/filter&gt;

  &lt;filter-mapping&gt;
      &lt;filter-name&gt;DirtyFilter&lt;/filter-name&gt;
      &lt;url-pattern&gt;/*&lt;/url-pattern&gt;
  &lt;/filter-mapping&gt;
</code></pre><p>当用户填写的内容包含一些敏感字符时，在DirtyFilter过滤器中就会将这些敏感字符替换掉。</p>
<p>　　我们如果将上述的CharacterEncodingFilter、HtmlFilter、DirtyFilter这三个过滤器联合起来使用，那么就相当于是把request对象包装了3次，request对象的getParameter方法经过3次重写，使得getParameter方法的功能大大增强，可以同时解决中文乱码，html标签转义，敏感字符过滤这些需求。</p>
<p>==在实际开发中完全可以将上述的三个过滤器合并成一个，让合并后的过滤器具有解决中文乱码，html标签转义，敏感字符过滤这些功能，例如：==</p>
<pre><code>package me.gacl.web.filter;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.UnsupportedEncodingException;
import java.util.ArrayList;
import java.util.List;

import javax.servlet.Filter;
import javax.servlet.FilterChain;
import javax.servlet.FilterConfig;
import javax.servlet.ServletException;
import javax.servlet.ServletRequest;
import javax.servlet.ServletResponse;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletRequestWrapper;
import javax.servlet.http.HttpServletResponse;

/**
* @ClassName: AdvancedFilter
* @Description: 这个过滤器是用来解决中文乱码，转义内容中的html标签，过滤内容中的敏感字符的
* @author: 孤傲苍狼
* @date: 2014-9-6 下午6:17:37
*
*/ 
public class AdvancedFilter implements Filter {

    private FilterConfig filterConfig = null;
    //设置默认的字符编码
    private String defaultCharset = &quot;UTF-8&quot;;

    @Override
    public void init(FilterConfig filterConfig) throws ServletException {
        //得到过滤器的初始化配置信息
        this.filterConfig = filterConfig;
    }

    @Override
    public void doFilter(ServletRequest req, ServletResponse resp,
            FilterChain chain) throws IOException, ServletException {
        HttpServletRequest request = (HttpServletRequest) req;
        HttpServletResponse response = (HttpServletResponse) resp;
        //得到在web.xml中配置的字符编码
        String charset = filterConfig.getInitParameter(&quot;charset&quot;);
        if(charset==null){
            charset = defaultCharset;
        }
        request.setCharacterEncoding(charset);
        response.setCharacterEncoding(charset);
        response.setContentType(&quot;text/html;charset=&quot;+charset);

        AdvancedRequest requestWrapper = new AdvancedRequest(request);
        chain.doFilter(requestWrapper, response);
    }

    @Override
    public void destroy() {

    }

    class AdvancedRequest extends HttpServletRequestWrapper{

        private List&lt;String&gt; dirtyWords = getDirtyWords();

        //定义一个变量记住被增强对象(request对象是需要被增强的对象)
        private HttpServletRequest request;
        //定义一个构造函数，接收被增强对象
        public AdvancedRequest(HttpServletRequest request) {
            super(request);
            this.request = request;
        }
        /* 覆盖需要增强的getParameter方法
         * @see javax.servlet.ServletRequestWrapper#getParameter(java.lang.String)
         */
        @Override
        public String getParameter(String name) {
            try{
                //获取参数的值
                String value= this.request.getParameter(name);
                if(value==null){
                    return null;
                }
                //如果不是以get方式提交数据的，就直接返回获取到的值
                if(!this.request.getMethod().equalsIgnoreCase(&quot;get&quot;)) {
                    //调用filter转义value中的html标签
                    value= filter(value);
                }else{
                    //如果是以get方式提交数据的，就对获取到的值进行转码处理
                    value = new String(value.getBytes(&quot;ISO8859-1&quot;),this.request.getCharacterEncoding());
                    //调用filter转义value中的html标签
                    value= filter(value);
                }

                for(String dirtyWord : dirtyWords){
                    if(value.contains(dirtyWord)){
                        System.out.println(&quot;内容中包含敏感词：&quot;+dirtyWord+&quot;，将会被替换成****&quot;);
                        //替换敏感字符
                        value = value.replace(dirtyWord, &quot;****&quot;);
                    }
                }
                return value;
            }catch (Exception e) {
                throw new RuntimeException(e);
            }
        }
    }

    /**
    * @Method: filter
    * @Description: 过滤内容中的html标签
    * @Anthor:孤傲苍狼
    * @param value
    * @return
    */ 
    public String filter(String value) {
        if (value == null){
            return null;
        }
        char content[] = new char[value.length()];
        value.getChars(0, value.length(), content, 0);
        StringBuffer result = new StringBuffer(content.length + 50);
        for (int i = 0; i &lt; content.length; i++) {
            switch (content[i]) {
            case &apos;&lt;&apos;:
                result.append(&quot;&amp;lt;&quot;);
                break;
            case &apos;&gt;&apos;:
                result.append(&quot;&amp;gt;&quot;);
                break;
            case &apos;&amp;&apos;:
                result.append(&quot;&amp;amp;&quot;);
                break;
            case &apos;&quot;&apos;:
                result.append(&quot;&amp;quot;&quot;);
                break;
            default:
                result.append(content[i]);
            }
        }
        return (result.toString());
    }

    /**
    * @Method: getDirtyWords
    * @Description: 获取敏感字符
    * @Anthor:孤傲苍狼
    *
    * @return
    */ 
    private List&lt;String&gt; getDirtyWords(){
        List&lt;String&gt; dirtyWords = new ArrayList&lt;String&gt;();
        String dirtyWordPath = filterConfig.getInitParameter(&quot;dirtyWord&quot;);
        InputStream inputStream = filterConfig.getServletContext().getResourceAsStream(dirtyWordPath);
        InputStreamReader is = null;
        try {
            is = new InputStreamReader(inputStream,defaultCharset);
        } catch (UnsupportedEncodingException e2) {
            e2.printStackTrace();
        }
        BufferedReader reader = new BufferedReader(is);
        String line;
        try {
            while ((line = reader.readLine())!= null) {//如果 line为空说明读完了
                dirtyWords.add(line);
            }
        } catch (IOException e) {
            e.printStackTrace();
        } 
        return dirtyWords;
    }
}
</code></pre><p>在web.xml文件中配置AdvancedFilter</p>
<pre><code>&lt;filter&gt;
      &lt;filter-name&gt;AdvancedFilter&lt;/filter-name&gt;
      &lt;filter-class&gt;me.gacl.web.filter.AdvancedFilter&lt;/filter-class&gt;
      &lt;init-param&gt;
         &lt;param-name&gt;charset&lt;/param-name&gt;    
         &lt;param-value&gt;UTF-8&lt;/param-value&gt;
    &lt;/init-param&gt;
      &lt;init-param&gt;
         &lt;param-name&gt;dirtyWord&lt;/param-name&gt;    
         &lt;param-value&gt;/WEB-INF/DirtyWord.txt&lt;/param-value&gt;
    &lt;/init-param&gt;
  &lt;/filter&gt;

  &lt;filter-mapping&gt;
      &lt;filter-name&gt;AdvancedFilter&lt;/filter-name&gt;
      &lt;url-pattern&gt;/*&lt;/url-pattern&gt;
  &lt;/filter-mapping&gt;
</code></pre><h2 id="三、使用Decorator设计模式增强response对象"><a href="#三、使用Decorator设计模式增强response对象" class="headerlink" title="三、使用Decorator设计模式增强response对象"></a>三、使用Decorator设计模式增强response对象</h2><p>　　Servlet  API 中提供了response对象的Decorator设计模式的默认实现类HttpServletResponseWrapper ，HttpServletResponseWrapper类实现了response接口中的所有方法，但这些方法的内部实现都是仅仅调用了一下所包装的的 response对象的对应方法，以避免用户在对response对象进行增强时需要实现response接口中的所有方法。</p>
<h3 id="3-1、response增强案例——压缩响应正文内容"><a href="#3-1、response增强案例——压缩响应正文内容" class="headerlink" title="3.1、response增强案例——压缩响应正文内容"></a>3.1、response增强案例——压缩响应正文内容</h3><p>　　应用HttpServletResponseWrapper对象，压缩响应正文内容。</p>
<p>　　具体思路:通过filter向目标页面传递一个自定义的response对象。在自定义的response对象中，重写getOutputStream方法和getWriter方法，使目标资源调用此方法输出页面内容时，获得的是我们自定义的ServletOutputStream对象。在我们自定义的ServletOuputStream对象中，重写write方法，使写出的数据写出到一个buffer中。当页面完成输出后，在filter中就可得到页面写出的数据，从而我们可以调用GzipOuputStream对数据进行压缩后再写出给浏览器，以此完成响应正文件压缩功能。</p>
<p>　　编写压缩过滤器，代码如下：   
　　</p>
<pre><code>package me.gacl.web.filter;

import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.io.OutputStreamWriter;
import java.io.PrintWriter;
import java.util.zip.GZIPOutputStream;

import javax.servlet.Filter;
import javax.servlet.FilterChain;
import javax.servlet.FilterConfig;
import javax.servlet.ServletException;
import javax.servlet.ServletOutputStream;
import javax.servlet.ServletRequest;
import javax.servlet.ServletResponse;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import javax.servlet.http.HttpServletResponseWrapper;

/**
* @ClassName: GzipFilter
* @Description: 压缩过滤器，将web应用中的文本都经过压缩后再输出到浏览器
* @author: 孤傲苍狼
* @date: 2014-9-7 上午10:52:42
*
*/ 
public class GzipFilter implements Filter {

    public void doFilter(ServletRequest req, ServletResponse resp,
            FilterChain chain) throws IOException, ServletException {

        HttpServletRequest request = (HttpServletRequest) req;
        HttpServletResponse response = (HttpServletResponse) resp;

        BufferResponse myresponse = new BufferResponse(response);
        chain.doFilter(request, myresponse);
        //拿出缓存中的数据，压缩后再打给浏览器
        byte out[] = myresponse.getBuffer();
        System.out.println(&quot;原始大小:&quot; + out.length);

        ByteArrayOutputStream bout = new ByteArrayOutputStream();
        //压缩输出流中的数据
        GZIPOutputStream gout = new GZIPOutputStream(bout);
        gout.write(out);
        gout.close();

        byte gzip[] = bout.toByteArray();
        System.out.println(&quot;压缩后的大小:&quot; + gzip.length);

        response.setHeader(&quot;content-encoding&quot;, &quot;gzip&quot;);
        response.setContentLength(gzip.length);
        response.getOutputStream().write(gzip);
    }

    public void destroy() {

    }

    public void init(FilterConfig filterConfig) throws ServletException {

    }
}

class BufferResponse extends HttpServletResponseWrapper{

    private ByteArrayOutputStream bout = new ByteArrayOutputStream();
    private PrintWriter pw;
    private HttpServletResponse response;
    public BufferResponse(HttpServletResponse response) {
        super(response);
        this.response = response;
    }
    @Override
    public ServletOutputStream getOutputStream() throws IOException {
        return new MyServletOutputStream(bout);
    }
    @Override
    public PrintWriter getWriter() throws IOException {
        pw = new PrintWriter(new OutputStreamWriter(bout,this.response.getCharacterEncoding()));
        return pw;
    }

    public byte[] getBuffer(){
        try{
            if(pw!=null){
                pw.close();
            }
            if(bout!=null){
                bout.flush();
                return bout.toByteArray();
            }


            return null;
        }catch (Exception e) {
            throw new RuntimeException(e);
        }
    }
}

class MyServletOutputStream extends ServletOutputStream{

    private ByteArrayOutputStream bout;
    public MyServletOutputStream(ByteArrayOutputStream bout){
        this.bout = bout;
    }

    @Override
    public void write(int b) throws IOException {
        this.bout.write(b);
    }
}　　
</code></pre><p>　　<br>　在web.xml中配置压缩过滤器
　
　</p>
<pre><code>&lt;filter&gt;
      &lt;description&gt;配置压缩过滤器&lt;/description&gt;
      &lt;filter-name&gt;GzipFilter&lt;/filter-name&gt;
      &lt;filter-class&gt;me.gacl.web.filter.GzipFilter&lt;/filter-class&gt;
  &lt;/filter&gt;

  &lt;!--jsp文件的输出的内容都经过压缩过滤器压缩后才输出 --&gt;
  &lt;filter-mapping&gt;
      &lt;filter-name&gt;GzipFilter&lt;/filter-name&gt;
      &lt;url-pattern&gt;*.jsp&lt;/url-pattern&gt;
      &lt;!-- 配置过滤器的拦截方式--&gt;
      &lt;!-- 对于在Servlet中通过
          request.getRequestDispatcher(&quot;jsp页面路径&quot;).forward(request, response) 
      方式访问的Jsp页面的要进行拦截 --&gt;
      &lt;dispatcher&gt;FORWARD&lt;/dispatcher&gt;
      &lt;!--对于直接以URL方式访问的jsp页面进行拦截，过滤器的拦截方式默认就是 REQUEST--&gt;
      &lt;dispatcher&gt;REQUEST&lt;/dispatcher&gt;
  &lt;/filter-mapping&gt;
  &lt;!--js文件的输出的内容都经过压缩过滤器压缩后才输出 --&gt;
  &lt;filter-mapping&gt;
      &lt;filter-name&gt;GzipFilter&lt;/filter-name&gt;
      &lt;url-pattern&gt;*.js&lt;/url-pattern&gt;
  &lt;/filter-mapping&gt;
  &lt;!--css文件的输出的内容都经过压缩过滤器压缩后才输出 --&gt;
  &lt;filter-mapping&gt;
      &lt;filter-name&gt;GzipFilter&lt;/filter-name&gt;
      &lt;url-pattern&gt;*.css&lt;/url-pattern&gt;
  &lt;/filter-mapping&gt;
  &lt;!--html文件的输出的内容都经过压缩过滤器压缩后才输出 --&gt;
  &lt;filter-mapping&gt;
      &lt;filter-name&gt;GzipFilter&lt;/filter-name&gt;
      &lt;url-pattern&gt;*.html&lt;/url-pattern&gt;
  &lt;/filter-mapping&gt;　
</code></pre><h3 id="3-2、response增强案例——缓存数据到内存"><a href="#3-2、response增强案例——缓存数据到内存" class="headerlink" title="3.2、response增强案例——缓存数据到内存"></a>3.2、response增强案例——缓存数据到内存</h3><p>　　对于页面中很少更新的数据，例如商品分类，为避免每次都要从数据库查询分类数据，因此可把分类数据缓存在内存或文件中，以此来减轻数据库压力，提高系统响应速度。</p>
<p>　　编写缓存数据的过滤器，代码如下：
　　</p>
<pre><code>package me.gacl.web.filter;

import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.io.OutputStreamWriter;
import java.io.PrintWriter;
import java.util.HashMap;
import java.util.Map;

import javax.servlet.Filter;
import javax.servlet.FilterChain;
import javax.servlet.FilterConfig;
import javax.servlet.ServletException;
import javax.servlet.ServletOutputStream;
import javax.servlet.ServletRequest;
import javax.servlet.ServletResponse;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import javax.servlet.http.HttpServletResponseWrapper;

/**
* @ClassName: WebResourceCachedFilter
* @Description: Web资源缓存过滤器
* @author: 孤傲苍狼
* @date: 2014-9-8 上午12:20:16
*
*/ 
public class WebResourceCachedFilter implements Filter {
    /**
    * @Field: map
    *          缓存Web资源的Map容器
    */ 
    private Map&lt;String,byte[]&gt; map = new HashMap&lt;String,byte[]&gt;();

    @Override
    public void init(FilterConfig filterConfig) throws ServletException {

    }

    @Override
    public void doFilter(ServletRequest req, ServletResponse resp,
            FilterChain chain) throws IOException, ServletException {
        HttpServletRequest request = (HttpServletRequest) req;
        HttpServletResponse response = (HttpServletResponse) resp;
        //1.得到用户请求的uri
        String uri = request.getRequestURI();
        //2.看缓存中有没有uri对应的数据
        byte b[] = map.get(uri);
        //3.如果缓存中有，直接拿缓存的数据打给浏览器，程序返回
        if(b!=null){
            //根据字节数组和指定的字符编码构建字符串
            String webResourceHtmlStr = new String(b,response.getCharacterEncoding());
            System.out.println(webResourceHtmlStr);
            response.getOutputStream().write(b);
            return;
        }
        //4.如果缓存没有，让目标资源执行，并捕获目标资源的输出
        BufferResponse myresponse = new BufferResponse(response);
        chain.doFilter(request, myresponse);
        //获取缓冲流中的内容的字节数组
        byte out[] = myresponse.getBuffer();
        //5.把资源的数据以用户请求的uri为关键字保存到缓存中
        map.put(uri, out);
        //6.把数据打给浏览器
        response.getOutputStream().write(out);
    }

    @Override
    public void destroy() {

    }

    class BufferResponse extends HttpServletResponseWrapper{
        private ByteArrayOutputStream bout = new ByteArrayOutputStream();  //捕获输出的缓存
        private PrintWriter pw;
        private HttpServletResponse response;
        public BufferResponse(HttpServletResponse response) {
            super(response);
            this.response = response;
        }
        @Override
        public ServletOutputStream getOutputStream() throws IOException {
            return new MyServletOutputStream(bout);
        }
        @Override
        public PrintWriter getWriter() throws IOException {
            pw = new PrintWriter(new OutputStreamWriter(bout,this.response.getCharacterEncoding()));
            return pw;
        }

        public byte[] getBuffer(){
            try{
                if(pw!=null){
                    pw.close();
                }
                return bout.toByteArray();
            }catch (Exception e) {
                throw new RuntimeException(e);
            }
        }
    }

    class MyServletOutputStream extends ServletOutputStream{
        private ByteArrayOutputStream bout;
        public MyServletOutputStream(ByteArrayOutputStream bout){  //接收数据写到哪里
            this.bout = bout;
        }
        @Override
        public void write(int b) throws IOException {
            bout.write(b);
        }
    }
}　　
</code></pre><p>在web.xml中配置Web资源缓存过滤器</p>
<pre><code>&lt;filter&gt;
       &lt;description&gt;Web资源缓存过滤器&lt;/description&gt;
      &lt;filter-name&gt;WebResourceCachedFilter&lt;/filter-name&gt;
      &lt;filter-class&gt;me.gacl.web.filter.WebResourceCachedFilter&lt;/filter-class&gt;
  &lt;/filter&gt;

  &lt;filter-mapping&gt;
      &lt;filter-name&gt;WebResourceCachedFilter&lt;/filter-name&gt;
      &lt;!-- 映射需要缓存输出的JSP页面，这几个页面都只是单纯作为输入UI，不会有太多的变化，因此可以缓存输出 --&gt;
      &lt;url-pattern&gt;/login.jsp&lt;/url-pattern&gt;
      &lt;url-pattern&gt;/test.jsp&lt;/url-pattern&gt;
      &lt;url-pattern&gt;/test2.jsp&lt;/url-pattern&gt;
  &lt;/filter-mapping&gt;
</code></pre>
      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        
  <div style="padding: 10px 0; margin: 20px auto; width: 90%; text-align: center;">
    <div>大爷！赏点电费钱吧！</div>
    <button id="rewardButton" disable="enable" onclick="var qr = document.getElementById('QR'); if (qr.style.display === 'none') {qr.style.display='block';} else {qr.style.display='none'}">
      <span>赏</span>
    </button>
    <div id="QR" style="display: none;">
      
        <div id="wechat" style="display: inline-block">
          <img id="wechat_qr" src="http://upload-images.jianshu.io/upload_images/3385496-bf8390384eef349d.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="杨重山 WeChat Pay"/>
          <p>微信打赏</p>
        </div>
      
      
        <div id="alipay" style="display: inline-block">
          <img id="alipay_qr" src="http://upload-images.jianshu.io/upload_images/3385496-af50d89c24bef0e5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="杨重山 Alipay"/>
          <p>支付宝打赏</p>
        </div>
      
    </div>
  </div>


      
    </div>


    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/j2ee/" rel="tag"># j2ee</a>
          
            <a href="/tags/filter/" rel="tag"># filter</a>
          
            <a href="/tags/servlet/" rel="tag"># servlet</a>
          
        </div>
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2017/01/06/sendRedirect-and-RequestDispatcher/" rel="next" title="请求重定向和请求分派">
                <i class="fa fa-chevron-left"></i> 请求重定向和请求分派
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2017/01/10/Junit/" rel="prev" title="Junit4使用实例">
                Junit4使用实例 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          

  <p>热评文章</p>
  <div class="ds-top-threads" data-range="weekly" data-num-items="4"></div>


          
  <div class="comments" id="comments">
    
      <div class="ds-thread" data-thread-key="2017/01/08/Decorator-filter/"
           data-title="servlet过滤器filter使用装饰器模式增强response和request对象" data-url="http://www.yanglc.com/2017/01/08/Decorator-filter/">
      </div>
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/image/touxiang.jpg"
               alt="杨重山" />
          <p class="site-author-name" itemprop="name">杨重山</p>
          <p class="site-description motion-element" itemprop="description">科学缩短了距离</p>
        </div>
        <nav class="site-state motion-element">
        
          
            <div class="site-state-item site-state-posts">
              <a href="/archives">
                <span class="site-state-item-count">18</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            <div class="site-state-item site-state-categories">
              <a href="/categories">
                <span class="site-state-item-count">5</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            <div class="site-state-item site-state-tags">
              <a href="/tags">
                <span class="site-state-item-count">22</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/ChongshanYang" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-github"></i>
                  
                  GitHub
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://weibo.com/p/1005052689345712" target="_blank" title="Weibo">
                  
                    <i class="fa fa-fw fa-weibo"></i>
                  
                  Weibo
                </a>
              </span>
            
          
        </div>

        
        

        
        
          <div class="links-of-blogroll motion-element links-of-blogroll-block">
            <div class="links-of-blogroll-title">
              <i class="fa  fa-fw fa-globe"></i>
              友情链接
            </div>
            <ul class="links-of-blogroll-list">
              
                <li class="links-of-blogroll-item">
                  <a href="http://www.jianshu.com/" title="JanShu" target="_blank">JanShu</a>
                </li>
              
                <li class="links-of-blogroll-item">
                  <a href="http://theme-next.iissnan.com/" title="Next" target="_blank">Next</a>
                </li>
              
                <li class="links-of-blogroll-item">
                  <a href="http://fontawesome.io/" title="Font awesome" target="_blank">Font awesome</a>
                </li>
              
                <li class="links-of-blogroll-item">
                  <a href="http://iissnan.com/progit/" title="Pro git" target="_blank">Pro git</a>
                </li>
              
                <li class="links-of-blogroll-item">
                  <a href="http://www.liaoxuefeng.com/" title="Liaoxuefeng" target="_blank">Liaoxuefeng</a>
                </li>
              
                <li class="links-of-blogroll-item">
                  <a href="http://www.runoob.com/" title="runoob" target="_blank">runoob</a>
                </li>
              
                <li class="links-of-blogroll-item">
                  <a href="http://w3schools.bootcss.com/default.html" title="w3schools" target="_blank">w3schools</a>
                </li>
              
                <li class="links-of-blogroll-item">
                  <a href="http://music.163.com/" title="Music" target="_blank">Music</a>
                </li>
              
                <li class="links-of-blogroll-item">
                  <a href="http://www.acfun.cn/" title="No BB" target="_blank">No BB</a>
                </li>
              
            </ul>
          </div>
        

        


      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#一、Decorator设计模式"><span class="nav-number">1.</span> <span class="nav-text">一、Decorator设计模式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-1、Decorator设计模式介绍"><span class="nav-number">1.1.</span> <span class="nav-text">1.1、Decorator设计模式介绍</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2、Decorator设计模式的实现"><span class="nav-number">1.2.</span> <span class="nav-text">1.2、Decorator设计模式的实现</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#二、使用Decorator设计模式增强request对象"><span class="nav-number">2.</span> <span class="nav-text">二、使用Decorator设计模式增强request对象</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1、使用Decorator模式包装request对象解决get和post请求方式下的中文乱码问题"><span class="nav-number">2.1.</span> <span class="nav-text">2.1、使用Decorator模式包装request对象解决get和post请求方式下的中文乱码问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2、使用Decorator模式包装request对象实现html标签转义功能"><span class="nav-number">2.2.</span> <span class="nav-text">2.2、使用Decorator模式包装request对象实现html标签转义功能</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-3、使用Decorator模式包装request对象实现敏感字符过滤功能"><span class="nav-number">2.3.</span> <span class="nav-text">2.3、使用Decorator模式包装request对象实现敏感字符过滤功能</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#三、使用Decorator设计模式增强response对象"><span class="nav-number">3.</span> <span class="nav-text">三、使用Decorator设计模式增强response对象</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-1、response增强案例——压缩响应正文内容"><span class="nav-number">3.1.</span> <span class="nav-text">3.1、response增强案例——压缩响应正文内容</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2、response增强案例——缓存数据到内存"><span class="nav-number">3.2.</span> <span class="nav-text">3.2、response增强案例——缓存数据到内存</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy;  2016 - 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">杨重山</span>
</div>



        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  



  
  <script type="text/javascript" src="//cdn.jsdelivr.net/jquery/2.1.3/jquery.min.js"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.0"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.0"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.0"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.0"></script>



  

  
    
  

  <script type="text/javascript">
    var duoshuoQuery = {short_name:"iissnan-notes"};
    (function() {
      var ds = document.createElement('script');
      ds.type = 'text/javascript';ds.async = true;
      ds.id = 'duoshuo-script';
      ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
      ds.charset = 'UTF-8';
      (document.getElementsByTagName('head')[0]
      || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
  </script>

  
    
      
      <script src="/lib/ua-parser-js/dist/ua-parser.min.js?v=0.7.9"></script>
      <script src="/js/src/hook-duoshuo.js?v=5.1.0"></script>
    
    
    <script src="/lib/ua-parser-js/dist/ua-parser.min.js?v=0.7.9"></script>
    <script src="/js/src/hook-duoshuo.js"></script>
  










  
  

  

  

  

  


</body>
</html>
